= libvirt second network 
Nick Hardiman 
:source-highlighter: pygments
:toc: 
:revdate: 17-06-2020


Create a second network named _private_, alongside _default_.

.networks 
[a2s,libvirt-second-network]
....
.----------------------------.
|                            |
|  host                      |
|                            |   
|   +----------+             |    
|   |          |             |
|   |  guest1  |             |  
|   |          +---> default +--> Internet  
|   |          |             |  
|   |          +---> private |   
|   +----------+             |
.----------------------------.  
....

All guests can join this new _private_ network and talk to each other.
Unlike _default_, this network is isolated because there is no connection to the outside world.
The host is also connected to the _private_ networkt. 
NetworkManager runs another copy of dnsmasq to provide DHCP and DNS services. 

Add a second network interface on guest1, and connect it to the new network. 
VM guest1 already has one network interface, eth0.
The current eth0 interface on the guest connects to the virbr0 interface on the host, and the new eth1 interface connects to virbr2.

.interfaces 
[a2s,libvirt-second-network-2]
....
.---------------------------.
|                           |
|  host                     |
|                           |   
|   +----------+            |    
|   |          |            |
|   |  guest1  |            |  
|   |          |            |  
|   |    eth0  +---> virbr0 | 
|   |          |            |  
|   |    eth1  +---> virbr2 |   
|   +----------+            |
.---------------------------.  
....


== behind the scenes 

Libvirt adds config, services and devices behind the scenes to make each network function.
Libvirt creates a dnsmasq configuration file, _/var/lib/libvirt/dnsmasq/(network).conf_. 
Dnsmasq handles DNS and DHCP queries. 
Libvirt adds a firewall zone (try running ``sudo firewall-cmd --list-all --zone=libvirt``). 
And it creates network interfaces.

For the _default_ network, libvirt creates a bridge interface named _virbr0_ and a NIC named _virbr0-nic_. 
Every time a VM starts, libvirt also creates a https://en.wikipedia.org/wiki/TUN/TAP[TAP] interface named something like _tap0_.  

The libvirt bridge _virbr0_ doesn't look like a real bridge - it doesn't connect two paths. 
A simple network bridge does connect two network interfaces, but 
virbr0 is a forwarding bridge.
It uses a forwarding database of layer 2 addresses (ethernet MAC addresses) to send packets to many destinations. 
View the forwarding database with the command ``bridge fdb``.
When an IP packet passes through virbr0 destined for the Internet, IP masquerading and forwarding get it to the outside world. 
When a packet is destined for a virtual machine, it's sent to the VM's TAP interface where the machine emulator https://www.qemu.org/[QEMU] picks it up. 

Most of these components are duplicated for the _private_ network. 
There is no IP masquerading and forwarding, so there is no communication with the outside world. 



== create a private network 

Create an XML file defining the interface. 
Run the command ``vim net-private.xml``.

Add XML. 
This markup is copied from the 
https://libvirt.org/formatnetwork.html#examplesPrivate[libvirt example].


[source,XML]
----
<network>
  <name>private</name>
  <bridge name="virbr2"/>
  <ip address="192.168.152.1" netmask="255.255.255.0">
    <dhcp>
      <range start="192.168.152.2" end="192.168.152.254"/>
    </dhcp>
  </ip>
  <ip family="ipv6" address="2001:db8:ca2:3::1" prefix="64"/>
</network>
----

Create the new network. Run ``sudo virsh net-define net-private.xml``

The network is created and is persistent - it will still exist across reboots. 
But it is not in use.

[source,console]
....
[nick@host ~]$ sudo virsh net-list --all
 Name                 State      Autostart     Persistent
----------------------------------------------------------
 default              active     yes           yes
 private              inactive   no            yes

[nick@host ~]$ 
....


Set the new network to start on boot, and start it now. 

[source,console]
....
[nick@host ~]$ sudo virsh net-start private
Network private started

[nick@host ~]$ 
[nick@host ~]$ sudo virsh net-autostart private
Network private marked as autostarted

[nick@host ~]$ 
[nick@host ~]$ sudo virsh net-list --all
 Name                 State      Autostart     Persistent
----------------------------------------------------------
 default              active     yes           yes
 private              active     yes           yes

[nick@host ~]$ 
....


=== check interfaces 

Libvirt creates a new bridge. 
Two new interfaces appear on the host, *virbr2* and *virbr2-nic*.
There is no need to create a bridge manually using ``nmcli connection``, ``ip link`` or ``bridge link`` commands. 

[source,console]
....
[nick@host ~]$ ip addr show
...
7: virbr2: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc noqueue state DOWN group default qlen 1000
    link/ether 52:54:00:5d:ff:fb brd ff:ff:ff:ff:ff:ff
    inet 192.168.152.1/24 brd 192.168.152.255 scope global virbr2
       valid_lft forever preferred_lft forever
    inet6 2001:db8:ca2:3::1/64 scope global 
       valid_lft forever preferred_lft forever
    inet6 fe80::5054:ff:fe5d:fffb/64 scope link 
       valid_lft forever preferred_lft forever
8: virbr2-nic: <BROADCAST,MULTICAST> mtu 1500 qdisc fq_codel master virbr2 state DOWN group default qlen 1000
    link/ether 52:54:00:5d:ff:fb brd ff:ff:ff:ff:ff:ff
[nick@host ~]$ 
....


=== loosen permissions 

libvirt uses qemu to do the hard work, and qemu uses ACLs (Access Control Lists). 
It won't let anyone use the new _virbr2_ interface. 
Let the VMs use the new network by copying permissions for the current _virbr0_ interface. 
Permissions for _virbr0_ are set in qemu's config file. 

[source,console]
....
[nick@host ~]$ cat /etc/qemu-kvm/bridge.conf 
allow virbr0
[nick@host ~]$ 
....

Add a similar line for the new bridge interface. 
[source,console]
....
[nick@host ~]$ sudo sh -c 'echo "allow virbr2" >> /etc/qemu-kvm/bridge.conf'
[nick@host ~]$ 
....



== add an interface to guest1 

The VM guest1 starts off with one interface. 
The command ``virsh domiflist guest1`` shows what interfaces are associated with this libvirt domain.

The VM has to be running before a second interface is added. 
In this example, the VM is not running.
Start the VM with the command ``virsh start guest1``.

[source,console]
....
[nick@host ~]$ virsh list --all
 Id    Name                           State
----------------------------------------------------
 -     guest1                         shut off

[nick@host ~]$ 
....

Use _virsh_ to add another interface. 

[source,console]
....
virsh attach-interface guest1 \
   --type bridge \
   --source virbr2 \
   --mac 52:54:00:00:01:00 \
   --model virtio \
   --live  \
   --config 
....

This command creates the _eth1_ interface on the guest VM. 
It also creates the  _tap1_ interface on the host.

[source,console]
....
[nick@host ~]$ virsh attach-interface guest1 --type bridge --source virbr2 --mac 52:54:00:00:01:00 --model virtio --live --config 
Interface attached successfully

[nick@host ~]$ 
[nick@host ~]$ virsh domiflist guest1
Interface  Type       Source     Model       MAC
-------------------------------------------------------
tap0       bridge     virbr0     virtio      52:54:00:00:00:01
tap1       bridge     virbr2     virtio      52:54:00:00:01:00

[nick@host ~]$ 
[nick@host ~]$ ip addr show dev tap1
16: tap1: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel master virbr2 state UNKNOWN group default qlen 1000
    link/ether fe:e0:2d:a1:68:2e brd ff:ff:ff:ff:ff:ff
    inet6 fe80::fce0:2dff:fea1:682e/64 scope link 
       valid_lft forever preferred_lft forever
[nick@host ~]$ 
....

The new guest interface may be ready to use - it depends on the guest OS. 
If the guest OS is RHEL 8, there's a new connection named _Wired connection 1_.
If it's RHEL 7, more NetworkManager configuration is required. 


== bring up the new eth1 interface  

Did NetworkManager configuration get added automatically?

Connect to the VM, either by running ``ssh guest1`` or by running ``virsh console guest1``.

Check to see the state of eth1.
This example doesn't need any more work. 

[source,console]
....
[nick@guest1 ~]$ nmcli dev
DEVICE  TYPE      STATE      CONNECTION         
eth0    ethernet  connected  System eth0        
eth1    ethernet  connected  Wired connection 1 
lo      loopback  unmanaged  --                 
[nick@guest1 ~]$ 
[nick@guest1 ~]$ nmcli con
NAME                UUID                                  TYPE      DEVICE 
System eth0         5fb06bd0-0bb0-7ffb-45f1-d6edd65f3e03  ethernet  eth0   
Wired connection 1  f9bd7074-8660-30bd-9154-e0e1cc49c89a  ethernet  eth1   
[nick@guest1 ~]$ 
[nick@guest1 ~]$ ip addr show dev eth1
3: eth1: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 52:54:00:00:01:00 brd ff:ff:ff:ff:ff:ff
    inet 192.168.152.98/24 brd 192.168.152.255 scope global dynamic noprefixroute eth1
       valid_lft 3145sec preferred_lft 3145sec
    inet6 2001:db8:ca2:3:f995:ccf6:9c82:4b9e/64 scope global dynamic noprefixroute 
       valid_lft 3584sec preferred_lft 3584sec
    inet6 fe80::875:44d6:d2a2:4a27/64 scope link noprefixroute 
       valid_lft forever preferred_lft forever
[nick@guest1 ~]$ 
....

The same commands give different results on RHEL 7. 

[source,console]
....
[nick@guest1 ~]# nmcli dev status
DEVICE  TYPE      STATE         CONNECTION  
eth0    ethernet  connected     System eth0 
eth1    ethernet  disconnected  --          
lo      loopback  unmanaged     --          
[nick@guest1 ~]#
[nick@guest1 ~]# nmcli con 
NAME         UUID                                  TYPE      DEVICE 
System eth0  5fb06bd0-0bb0-7ffb-45f1-d6edd65f3e03  ethernet  eth0   
[nick@guest1 ~]# 
....

If no connection is defined, create one with these commands. 
These commands may also create an old-style config file at _/etc/sysconfig/network-scripts/ifcfg-eth1_.

[source,console]
....
sudo nmcli con add type ethernet con-name eth1 ifname eth1 
sudo nmcli con up eth1
....


== next steps 

